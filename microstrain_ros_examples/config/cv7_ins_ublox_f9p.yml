/**/microstrain_inertial_driver:
  ros__parameters:
    # This can be set by passing an var to the launch file
    port     : /dev/microstrain_main
    baudrate : 115200
    set_baud : True

    # Disable the transform from the mount to frame id transform as it should be handled from a URDF file and robot_description
    publish_mount_to_frame_id_transform : False

    # This will cause the node to convert any NED measurements to ENU
    # This will also cause the node to convert any vehicle frame measurements to the ROS definition of a vehicle frame
    use_enu_frame : True

    # Configure some frame IDs
    frame_id          : cv7_ins_link  # Frame ID of all of the filter messages. Represents the location of the Cv7-INS in the tf tree
    map_frame_id      : map           # Frame ID of the global tangent plane.
    earth_frame_id    : earth         # Frame ID of the global frame
    target_frame_id   : base_link     # Frame ID that we will publish a transform to.

    # We will use relative transform mode, meaning that we will publish the following transforms from this node
    #   earth_frame_id -> map_frame_id
    #   map_frame_id -> target_frame_id
    # This helps ROS standard tools consume and display position information produced by the device.
    tf_mode: 2

    # This configuration will ensure that the driver publishes position relative to a global tangent plane
    # The origin of the tangent plane will be represented in the tf tree by map_frame_id, and will be the location where the filter first enters full nav.
    # If you want a constant position for the global tangent plane, see the documentation below
    #     Reference frame =
    #         1 - Relative ECEF position
    #         2 - Relative LLH position
    #
    #     Source =
    #         0 - Position will be reported relative to the base station. filter_relative_position_ref will be ignored
    #         1 - Position will be reported relative to filter_relative_position_ref
    #         2 - Position will be reported relative to the first position reported by the device after it enters full nav. filter_relative_position_ref will be ignored
    #         3 - We will wait for a transform to be made available between earth_frame_id and map_frame_id and use that as the relative position reference. filter_relative_position_ref will be ignored
    #
    #     Reference position - Units provided by reference frame (ECEF - meters, LLH - deg, deg, meters)
    filter_relative_position_config : True
    filter_relative_position_source : 2
    filter_relative_position_frame  : 2
    filter_relative_position_ref    : [0.0, 0.0, 0.0]

    # (GQ7 only) Filter Initialization control
    #     Auto-Heading alignment selector (note this is a bitfield, you can use more than 1 source) =
    #         Bit 0 - Dual-antenna GNSS
    #         Bit 1 - GNSS kinematic (requires motion, e.g. a GNSS velocity)
    #         Bit 2 - Magnetometer
    #         Bit 3 - External Heading (first valid external heading will be used to initialize the filter)
    # This sets the heading alignment to use only the magnetometer
    filter_auto_heading_alignment_selector : 2

    # Setup some aiding options.
    filter_enable_gnss_pos_vel_aiding : True
    filter_enable_gnss_heading_aiding : False

    # This example shows a very basic setup with no PPS sync, so the PPS will be generated by the device's oscillator for drift constaint
    filter_pps_source : 4

    # Disable the filter declination source. This is required to get the node to start, and isn't doing anything special
    filter_declination_source : 1

    # For this use case, we will not publish any IMU data
    imu_data_rate : 0

    # The CV7-INS does not have any onboard GNSS receivers, so we would not be able to publish this data either way.
    # Global position data can be seen in the filter publishers configured below
    gnss1_llh_position_data_rate   : 0
    gnss1_velocity_data_rate       : 0
    gnss1_odometry_earth_data_rate : 0
    gnss2_llh_position_data_rate   : 0
    gnss2_velocity_data_rate       : 0
    gnss2_odometry_earth_data_rate : 0

    # We will publish the global position in both ECEF and LLH for this example
    # Also publish the human readable message which can be echoed from the command line
    filter_human_readable_status_data_rate : 1
    filter_llh_position_data_rate          : 50
    filter_odometry_earth_data_rate        : 50
    filter_odometry_map_data_rate          : 50

    # Subscribe to the aiding messages.
    # For this example we are just subscribing to external GNSS position and velocity
    subscribe_ext_fix     : True
    subscribe_ext_vel_enu : True

/**/ntrip_client:
  ros__parameters:
    # These can be set by passing args to the launch file
    host       : $(var ntrip_host)
    port       : $(var ntrip_port)
    mountpoint : $(var ntrip_mountpoint)

    # For this example, we will always assume that we are going to authenticate
    authenticate : true
    username : $(var ntrip_username)
    password : $(var ntrip_password)

    # If your NTRIP caster uses port 443 or 2102, you should probably set this to true in order to connect over HTTPS
    ssl : $(var ntrip_ssl false)

    # Since the RTCM will be coming from the RTK base station whose position may be the map frame, set the frame id to map
    rtcm_frame_id : "map"

    # Use the smaller RTCM message option
    rtcm_message_package : "rtcm_msgs"

    # Make sure that we can accept longer NMEA sentences
    nmea_max_length: 128

/**/ublox_f9p:
  ros__parameters:
    # Connect to the requested port
    device: $(var ublox_f9p_port)

    # This frame_id represents the location of the antenna, not the chip.
    frame_id: "ublox_f9p_antenna_link"

    # Enable all the constellations
    gnss:
      gps: true
      glonass: true
      galileo: true
      beidou: true

    # Whether to display all INF messages in console
    inf:
      all: true

    # Disable tmode3
    tmode3: 0